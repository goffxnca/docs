"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[9399],{55777:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var a=n(85893),r=n(11151);const o={sidebar_label:"Indexer Framework"},i="NEAR Indexer Framework",s={id:"concepts/advanced/near-indexer-framework",title:"NEAR Indexer Framework",description:"https://github.com/near/nearcore/tree/master/chain/indexer",source:"@site/../docs/1.concepts/3.advanced/near-indexer-framework.md",sourceDirName:"1.concepts/3.advanced",slug:"/concepts/advanced/near-indexer-framework",permalink:"/docs/ko/concepts/advanced/near-indexer-framework",draft:!1,unlisted:!1,editUrl:"https://github.com/near/docs/edit/master/website/../docs/1.concepts/3.advanced/near-indexer-framework.md",tags:[],version:"current",lastUpdatedBy:"Lyudmil Ivanov",lastUpdatedAt:1718807151e3,frontMatter:{sidebar_label:"Indexer Framework"}},c={},d=[{value:"Description",id:"description",level:2},{value:"Rationale",id:"rationale",level:2},{value:"Limitations",id:"limitations",level:2},{value:"Current Status",id:"current-status",level:2},{value:"Applications",id:"applications",level:2}];function l(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",ul:"ul",...(0,r.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"near-indexer-framework",children:"NEAR Indexer Framework"})}),"\n",(0,a.jsx)(t.admonition,{title:"GitHub repo",type:"note",children:(0,a.jsx)(t.p,{children:(0,a.jsx)(t.a,{href:"https://github.com/near/nearcore/tree/master/chain/indexer",children:"https://github.com/near/nearcore/tree/master/chain/indexer"})})}),"\n",(0,a.jsx)(t.admonition,{title:"You might be looking for NEAR Lake Framework",type:"caution",children:(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.a,{href:"/docs/ko/concepts/advanced/near-lake-framework",children:"NEAR Lake Framework"})," is a lightweight alternative to NEAR Indexer Framework that is recommended for use when centralization can be tolerated."]})}),"\n",(0,a.jsx)(t.h2,{id:"description",children:"Description"}),"\n",(0,a.jsxs)(t.p,{children:["NEAR Indexer Framework is a Rust package (crate) that embeds ",(0,a.jsx)(t.a,{href:"https://github.com/near/nearcore",children:"nearcore"}),", and abstracts away all the complexities of collecting every bit of information related to each produced block in NEAR network. The crate name is ",(0,a.jsx)(t.a,{href:"https://github.com/near/nearcore/tree/master/chain/indexer",children:(0,a.jsx)(t.code,{children:"near-indexer"})}),", and it is part of the ",(0,a.jsx)(t.a,{href:"https://github.com/near/nearcore",children:"nearcore repository"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"near-indexer"}),' is a micro-framework, which provides you with a stream of blocks that are recorded on NEAR network. It is useful to handle real-time "events" on the chain.']}),"\n",(0,a.jsx)(t.h2,{id:"rationale",children:"Rationale"}),"\n",(0,a.jsx)(t.p,{children:"As scaling dApps enter NEAR\u2019s mainnet, an issue may arise: how do they quickly and efficiently access state from our deployed smart contracts, and cut out the cruft? Contracts may grow to have complex data structures and querying the network RPC may not be the optimal way to access state data. The NEAR Indexer Framework allows for streams to be captured and indexed in a customized manner. The typical use-case is for this data to make its way to a relational database. Seeing as this is custom per project, there is engineering work involved in using this framework."}),"\n",(0,a.jsx)(t.h2,{id:"limitations",children:"Limitations"}),"\n",(0,a.jsx)(t.p,{children:"NEAR Indexer Framework embeds the full NEAR node and thus requires to sync with the peer-to-peer network and store all the network data locally thus it is subject to the storage requirements, which is hundreds of GBs on SSD if you only need to extract the data that is not older than ~2.5 days, and thousands of GBs on SSD if you want to be able to go over the whole history of the network. Also, the network sync process is known to be extremely slow (while the block production is 1 block per second, while the block sync usually reaches 2 blocks per second, which means that it is capable to catch up with the live network at a speed of 1 block per second, so if your node was offline for one hour, it will take one hour to catch up to the tip of the network that keeps getting freshly produced blocks)."}),"\n",(0,a.jsx)(t.p,{children:"NEAR Indexer Framework only exposes the blocks that were finalized. In NEAR Protocol, it takes 3 consecutive blocks to get the block finalized which means that there is at least a 3-second delay between the time when some transaction hits the network, and the time it is finalized and streamed from NEAR Indexer Framework. If we measure the delay between the moment when a transaction gets submitted from the client device to the moment Indexer Framework-based indexers would receive it, we can see the following timings:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["A serialized transaction being transferred over the Internet to NEAR node (most commonly, through ",(0,a.jsx)(t.a,{href:"https://docs.near.org/api/rpc/transactions#send-transaction-await",children:"NEAR JSON RPC broadcast_tx_commit"}),"): around 50ms (it is not measured precisely as it is mostly network latency of TCP handshake + HTTPS handshake)"]}),"\n",(0,a.jsxs)(t.li,{children:["The transaction is routed to the ",(0,a.jsx)(t.a,{href:"https://near-nodes.io/intro/what-is-a-node",children:"validation node"}),": around 50ms (again, mostly network latency between the peer nodes)"]}),"\n",(0,a.jsx)(t.li,{children:"The transaction arrives in the mempool on the validation node and will be delayed at least until the next chunk/block is produced, so if the transaction was received right at the moment when transactions for the current block were selected, it would take 1.2 seconds on mainnet to get the next block produced"}),"\n",(0,a.jsxs)(t.li,{children:["Once the transaction is included in a block, it will produce a receipt which often will be executed in the next block (another 1.2-second delay) - learn more about the NEAR Protocol data flow ",(0,a.jsx)(t.a,{href:"/docs/ko/concepts/data-flow/near-data-flow",children:"here"})]}),"\n",(0,a.jsx)(t.li,{children:"Given that block finalization takes 3 blocks (1.2 seconds * 3), Indexer Framework will only get the opportunity to start collecting the information about the block where the transaction was included 3.6 seconds later, but we should also include at least a 50ms delay that is introduced by the network latency when produced blocks propagate back from the validation nodes back to the regular nodes"}),"\n",(0,a.jsx)(t.li,{children:"Indexer Framework then collects all the bits of information for the produced block and streams it: around 50-100ms"}),"\n",(0,a.jsx)(t.li,{children:"Custom indexer implementation receives the block and there could be additional delays down the line, but that is outside of our scope here"}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["Ultimately, it takes at least 3.8 seconds from the moment one submits a transaction to the network, and Indexer Framework-based indexers pick it up, where the finalization time contributes the most of the delay. In real life scenario, dApps usually need to know the result of the execution, and so it will take a couple of blocks after the transaction is included to get all the receipts executed (read more about the data flow ",(0,a.jsx)(t.a,{href:"/docs/ko/concepts/data-flow/near-data-flow",children:"here"}),"), so the delay between the transaction submission and the result being observed by an indexer could be 5-7 seconds."]}),"\n",(0,a.jsx)(t.h2,{id:"current-status",children:"Current Status"}),"\n",(0,a.jsx)(t.p,{children:"Indexer Framework is a tool that provides a straightforward way of getting a stream of finalized NEAR Protocol blocks as soon as possible operating over a decentralized NEAR Protocol peer-to-peer network."}),"\n",(0,a.jsxs)(t.p,{children:["However, in our experiments with the Indexer ecosystem, we realized that we need a lightweight foundation to build micro-indexers instead of maintaining a full ",(0,a.jsx)(t.a,{href:"https://github.com/near/nearcore",children:"nearcore"})," node. We considered various solutions to deliver events (Kafka, RabbitMQ, etc), but ultimately we decided to dump all the blocks as is to AWS S3 bucket. This is where NEAR Lake ecosystem was born, learn more about it ",(0,a.jsx)(t.a,{href:"/docs/ko/concepts/advanced/near-lake-framework",children:"here"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["These days, we use NEAR Indexer Framework to implement ",(0,a.jsx)(t.a,{href:"https://github.com/near/near-lake-indexer",children:"NEAR Lake Indexer"})," and from there we build micro-indexers based on ",(0,a.jsx)(t.a,{href:"/docs/ko/concepts/advanced/near-lake-framework",children:"NEAR Lake Framework"}),". Having said that, Indexer Framework plays a crucial role in the ecosystem even though most of the indexers these days are implemented without using it directly."]}),"\n",(0,a.jsx)(t.h2,{id:"applications",children:"Applications"}),"\n",(0,a.jsxs)(t.p,{children:["See the ",(0,a.jsx)(t.a,{href:"https://github.com/nearprotocol/nearcore/tree/master/tools/indexer/example",children:"example"})," for further technical details."]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.a,{href:"https://github.com/near-examples/indexer-tx-watcher-example",children:(0,a.jsx)(t.code,{children:"near-examples/indexer-tx-watcher-example"})})," NEAR Indexer example that watches for transaction for specified accounts/contracts"]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},11151:(e,t,n)=>{n.d(t,{Z:()=>s,a:()=>i});var a=n(67294);const r={},o=a.createContext(r);function i(e){const t=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),a.createElement(o.Provider,{value:t},e.children)}}}]);