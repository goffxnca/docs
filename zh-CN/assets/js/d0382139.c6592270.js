"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[5180],{58541:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>l});var n=a(85893),i=a(11151);const s={id:"nfts",title:"NFTs for Web 2 Applications",sidebar_label:"NFTs for Web 2.0 Apps"},o="NFTs for Web 2 Applications",r={id:"concepts/web3/nfts",title:"NFTs for Web 2 Applications",description:"At the first stage of our Web 3 transformation, let\u2019s decentralize ownership of our digital assets using blockchain technology. By doing this, we can create a user-owned economy, where digital assets are exchanged and traded without any participation or control from the developers. Later, we\u2019ll discuss how to bring it to the next level by adding Fungible Tokens into the mix.",source:"@site/../docs/1.concepts/web3/nfts.md",sourceDirName:"1.concepts/web3",slug:"/concepts/web3/nfts",permalink:"/docs/zh-CN/concepts/web3/nfts",draft:!1,unlisted:!1,editUrl:"https://github.com/near/docs/edit/master/website/../docs/1.concepts/web3/nfts.md",tags:[],version:"current",lastUpdatedBy:"Lyudmil Ivanov",lastUpdatedAt:1730307732e3,frontMatter:{id:"nfts",title:"NFTs for Web 2 Applications",sidebar_label:"NFTs for Web 2.0 Apps"},sidebar:"concepts",previous:{title:"Economics",permalink:"/docs/zh-CN/concepts/web3/economics"}},c={},l=[{value:"Blockchain-Enabled Application Architecture",id:"blockchain-enabled-application-architecture",level:2},{value:"NFTs in Web 2 Applications",id:"nfts-in-web-2-applications",level:2},{value:"Authentication and Authorization",id:"authentication-and-authorization",level:3},{value:"Blockchain Auth &amp; Auth",id:"blockchain-auth--auth",level:4},{value:"NFT usage",id:"nft-usage",level:3},{value:"NFT minting",id:"nft-minting",level:3},{value:"Blockchain Onboarding",id:"blockchain-onboarding",level:2},{value:"NFT Marketplace",id:"nft-marketplace",level:2},{value:"Implementing Components",id:"implementing-components",level:2},{value:"Client &amp; Server",id:"client--server",level:4},{value:"Contracts",id:"contracts",level:4},{value:"Off-chain storages",id:"off-chain-storages",level:4},{value:"Indexer",id:"indexer",level:4},{value:"Automated Testing",id:"automated-testing",level:4},{value:"Non-Functional Concerns",id:"non-functional-concerns",level:2},{value:"Security",id:"security",level:3},{value:"Scalability and Availability",id:"scalability-and-availability",level:3},{value:"Costs",id:"costs",level:3}];function d(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,i.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"nfts-for-web-2-applications",children:"NFTs for Web 2 Applications"})}),"\n",(0,n.jsx)(t.p,{children:"At the first stage of our Web 3 transformation, let\u2019s decentralize ownership of our digital assets using blockchain technology. By doing this, we can create a user-owned economy, where digital assets are exchanged and traded without any participation or control from the developers. Later, we\u2019ll discuss how to bring it to the next level by adding Fungible Tokens into the mix."}),"\n",(0,n.jsx)(t.p,{children:"As we discussed previously, in the Web 3 world, NFTs are used to represent ownership of an asset. This can be anything a user owns, e.g. in case of a game this can be a character, upgrade, crafting material, skin, etc. However, since NFTs are living on the blockchain, and the rest of the application resides on traditional servers, we need to find a way to connect these different worlds together."}),"\n",(0,n.jsx)(t.h2,{id:"blockchain-enabled-application-architecture",children:"Blockchain-Enabled Application Architecture"}),"\n",(0,n.jsx)(t.p,{children:"First of all, let\u2019s outline a typical architecture of a Web 2 application. In most cases, a classic client-server model is used:"}),"\n",(0,n.jsx)("div",{align:"center",children:(0,n.jsx)("img",{src:"/docs/assets/web3/nfts-1.png",alt:"image",width:"150"})}),"\n",(0,n.jsx)(t.p,{children:"In such architecture, we usually have 3 layers:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Database - stores application\u2019s data. This can be a single database, or several databases of different types, but this is mostly an implementation detail - for our purposes we can view it as a single logical database."}),"\n",(0,n.jsx)(t.li,{children:"Server - a centralized web-server. It may be implemented using different architecture patterns (monolithic, microservices, serverless) and technologies, but again, we can consider it as a single logical server."}),"\n",(0,n.jsx)(t.li,{children:"Client - client side application user directly interacts with. Different client types are possible: web, mobile or desktop. There is a difference between these clients in regards to blockchain integration, which we\u2019ll discuss later."}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"Now, let\u2019s compare it to a dApp architecture:"}),"\n",(0,n.jsx)("div",{align:"center",children:(0,n.jsx)("img",{src:"/docs/assets/web3/nfts-2.png",alt:"image",width:"400"})}),"\n",(0,n.jsx)(t.p,{children:"We can notice that there is a common component in these architectures - the client application. This means we can use it as a junction point to connect them together."}),"\n",(0,n.jsx)("div",{align:"center",children:(0,n.jsx)("img",{src:"/docs/assets/web3/nfts-3.png",alt:"image",width:"400"})}),"\n",(0,n.jsx)(t.p,{children:"A keen reader may notice an additional connection between the Server and RPC Node. This is required because in a client-server architecture clients cannot be trusted. That\u2019s why every action performed from the client should be validated by a backend server. But in our case everything is complicated by the fact that we essentially have two backends: Web 2 server and a smart contract, so two possible validation flows are possible:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Client performs an action on a server, which involves blockchain data. In this case the server should talk to the blockchain and verify that valid data is provided."}),"\n",(0,n.jsxs)(t.li,{children:["Client performs an action on a smart contract, which involves server-owned data. Since the smart contract can\u2019t talk to the server directly to verify it, we should use a different way to verify the authenticity of the data. In blockchain terminology, such a server is called an ",(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Blockchain_oracle",children:"Oracle"}),".\nWe\u2019ll explore how to implement both of these approaches later."]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["By now, we've reached the point where the type of our client begins to matter. Specifically, problems arise from the dApps payment model - user\u2019s pay for the blockchain infrastructure using gas, so money goes directly to infrastructure providers. Also, users make payments directly on the blockchain, without using any intermediaries, like banks or payment services. This approach is at odds with mobile app stores (Google Play Store and Apple App Store) - they don\u2019t allow any payments on their respective mobile platforms without their cut. Although some shifts in policy are starting to happen (e.g. ",(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Epic_Games_v._Apple",children:"Apple vs Epic Games duel"}),"), at the time of this writing getting blockchain-enabled applications into the stores will probably get vetoed by reviewers. There are some ways to bypass these limitations, e.g. by not using Play Store on Android, but all of these ways are either sub-par in terms of usability or involve some risk of getting banned by stores. That\u2019s why for mobile applications an alternative approach is needed."]}),"\n",(0,n.jsx)(t.p,{children:"Sometimes, to move forward we need to take a step back. In our case, to solve a problem with mobile clients we can return to our initial concept of having two clients - one for blockchain integration, and another one for Web 2 server. Blockchain client can be a usual web application, which isn\u2019t subject to any constraints from stores. It can also serve as a connection point between blockchain and our existing application."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"image",src:a(5645).Z+"",width:"1572",height:"1600"})}),"\n",(0,n.jsx)(t.p,{children:"In this architecture the mobile client is still allowed to talk to the blockchain, but only in a read-only way, which doesn\u2019t require wallet connection or any payments. All actions on the blockchain happen on the Web Client instead.\nFurther in this guide we\u2019ll use such dual-client architecture, since simpler architecture with a single client can be directly derived from it by merging two clients together."}),"\n",(0,n.jsx)(t.p,{children:"At this point, our architecture covers almost everything we need to start building our application. However, since we want to build a user-owned economy, we need a marketplace where it\u2019ll happen. An obvious choice is to put this marketplace into the web client, but there\u2019s one gotcha. If we recall the smart contract\u2019s storage model, it\u2019s not suitable to serve complex data queries, so an indexer should be used to aggregate data from blockchain into a proper database."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"image",src:a(52538).Z+"",width:"1575",height:"1600"})}),"\n",(0,n.jsx)(t.p,{children:"By now, every building-block is in place and we can start exploring how to implement this architecture in practice."}),"\n",(0,n.jsx)(t.h2,{id:"nfts-in-web-2-applications",children:"NFTs in Web 2 Applications"}),"\n",(0,n.jsx)(t.p,{children:"In order to implement a fully functional application using a hybrid Web 2 - Web 3 architecture, a lot of technological challenges have to be addressed, like authentication and authorization, seamless NFTs usage in client and server, and proper NFT storage model. In the following sections we\u2019ll take a closer look at this and describe common patterns and approaches."}),"\n",(0,n.jsx)(t.h3,{id:"authentication-and-authorization",children:"Authentication and Authorization"}),"\n",(0,n.jsx)(t.p,{children:"Since our digital assets are represented as NFTs on blockchain, in order to use them in our Web 2 application, a server needs a way to authorize their usage. The basic idea is pretty simple - it can just read data from blockchain by calling a smart contract method and check an owner\u2019s account id. For such flow, we have 3 actors:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Client that wants to use some digital asset (NFT)."}),"\n",(0,n.jsxs)(t.li,{children:["Smart Contract for NFTs. Should be implemented according to ",(0,n.jsx)(t.a,{href:"https://nomicon.io/Standards/NonFungibleToken/",children:"NEAR NFT standards"}),"."]}),"\n",(0,n.jsx)(t.li,{children:"Server that verifies ownership of NFT and uses it in its internal logic."}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"A general flow looks like this:"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"image",src:a(47471).Z+"",width:"1600",height:"1056"})}),"\n",(0,n.jsx)(t.p,{children:"However, such an authorization process cannot be performed without authentication, so the server also needs a way to authenticate a user."}),"\n",(0,n.jsx)(t.p,{children:"Recall that the user's identity on a blockchain is represented by a key pair. However, since in NEAR a user may have multiple key pairs and an account is a separate entity, the authentication procedure is a bit more complicated."}),"\n",(0,n.jsx)(t.p,{children:"To authenticate our requests, we can use public-key cryptography - a client can sign a request using a user\u2019s private key, and then a server can verify the signature and key ownership. A typical request with authentication may look like this:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-javascript",children:'{\n\t"payload": { /* request-specific payload */ },\n\t"accountId": "account.near",\n\t"publicKey": "...",\n\t"timestamp": 1647091283342,\n\t"signature": "..."\n}\n'})}),"\n",(0,n.jsx)(t.p,{children:"where:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"accountId"})," \u2013 user\u2019s account id on NEAR."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"publicKey"})," - public key of the key pair used for signature, must be either Functional or Full access key for the provided account."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"timestamp"})," - current datetime, must be verified on server. It\u2019s needed to prevent ",(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Replay_attack",children:"replay attacks"}),". Alternative to timestamps is usage of ",(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Cryptographic_nonce",children:"nonce"}),", but it\u2019s more complicated."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:"signature"})," - signature of the request payload and other fields. Usually, a payload is hashed beforehand."]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"Depending on the implementation, request body, headers, or other side channels can be used to transfer authentication data - exact implementation depends on used technologies and protocols."}),"\n",(0,n.jsx)(t.p,{children:"Server can use this data to authenticate a request using the following approach:"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"image",src:a(44705).Z+"",width:"1600",height:"1061"})}),"\n",(0,n.jsx)(t.p,{children:"3 authentication steps are performed on the server:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsx)(t.li,{children:"Signature verification - if the signature is correct, we are sure that the client really has the private key for the provided public key. Also, this proves that request data hasn't been modified in transit."}),"\n",(0,n.jsx)(t.li,{children:"Timestamp verification - prevents replay attacks. Server can verify that the request\u2019s timestamp is not too old (e.g. has been created no more than 10 seconds ago)."}),"\n",(0,n.jsxs)(t.li,{children:["Public key ownership verification - by calling ",(0,n.jsx)(t.a,{href:"/docs/zh-CN/api/rpc/access-keys",children:"view_access_key method"}),", we can make sure that the provided public key is really associated with the provided account."]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"Such authentication approach is the simplest one, but has a few major drawbacks:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Performing a REST API call to RPC Node is quite expensive to do each time from the performance perspective."}),"\n",(0,n.jsx)(t.li,{children:"We can\u2019t sign requests from the mobile client, since it usually should be disconnected from the blockchain due to store policies, and hence doesn\u2019t have a key pair."}),"\n",(0,n.jsx)(t.li,{children:"A NEAR account is required in order to start using the application, which complicates the onboarding process."}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"To solve the first problem, we can simply issue a JWT token or authenticate connection in some other way after a successful NEAR account authentication, so the it will serve as \u201clogin\u201d of sorts:"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"image",src:a(61243).Z+"",width:"1600",height:"1523"})}),"\n",(0,n.jsx)(t.p,{children:"While this may be enough for some applications, it doesn\u2019t address the last 2 problems. In order to solve all of them, we can use a hybrid authentication approach with 2 accounts:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsx)(t.li,{children:"\u201cClassic\u201d Web 2 account - all clients can use this account to call a server. For example, this can be a simple username/password or OAuth 2 login with a JWT token."}),"\n",(0,n.jsx)(t.li,{children:"NEAR account - can be used from non-mobile clients only. Instead of performing NEAR account auth each time we need to use it, we can do it a single time in order to \u201cconnect\u201d this account to our primary Web 2 account and store Classic-NEAR account connection in our server database. In this way we solve all problems - server doesn\u2019t need to authenticate NEAR account each time it wants to perform an authorization, instead it can read an associated NEAR account from its own database."}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"With such hybrid approach, different authentication methods are used for blockchain and server:"}),"\n",(0,n.jsx)("div",{align:"center",children:(0,n.jsx)("img",{src:"/docs/assets/web3/nfts-9.png",alt:"image",width:"400"})}),"\n",(0,n.jsx)(t.p,{children:"NEAR account connection sequence can be implemented in a very similar way to the already described NEAR authentication method, where at the end we store an authenticated account in our database:"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"image",src:a(97793).Z+"",width:"1600",height:"1343"})}),"\n",(0,n.jsx)(t.p,{children:"There\u2019s one more improvement we can make to this flow. Since a Web Client uses both accounts, a user is forced to login using both Web 2 login method (e.g. login/password) and NEAR Wallet. This is not ideal from the UX perspective, so we can simplify it by introducing a \u201cLogin with Wallet\u201d method to our server, which would work when a user already has a wallet connected. We can do this in a similar way to the account connection flow:"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"image",src:a(24660).Z+"",width:"2002",height:"2048"})}),"\n",(0,n.jsx)(t.p,{children:"Now, as we\u2019ve discussed possible approaches for authentication, let\u2019s summarize it as an overall login flow for our clients:"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"image",src:a(27273).Z+"",width:"1600",height:"930"})}),"\n",(0,n.jsx)(t.p,{children:"Of course, this is just one possible flow, and a different solution can be assembled from described building blocks. The most important considerations for choosing right authentication flow are following:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Type of your client - for web/desktop clients, or sideloaded Android clients, it\u2019s possible to use Wallet as a single authentication method. For mobile clients installed from a store, a hybrid approach with multiple auth methods should be used."}),"\n",(0,n.jsx)(t.li,{children:"Target audience - if you target regular users that are not familiar with blockchain technologies, having a hybrid auth method to simplify onboarding might be better than forcing users to learn blockchain before trying your application."}),"\n"]}),"\n",(0,n.jsx)(t.h4,{id:"blockchain-auth--auth",children:"Blockchain Auth & Auth"}),"\n",(0,n.jsx)(t.p,{children:"So far, we\u2019ve discussed authentication and authorization on the Web 2 server\u2019s side. But what about Web 3 smart contracts? Everything is much more straightforward in this case."}),"\n",(0,n.jsxs)(t.p,{children:["Since everything is public data on the blockchain, we don\u2019t need any authentication for read calls. For transactions, each is signed by an account\u2019s private key, and authentication is performed by the network. More details on transaction signing can be found ",(0,n.jsx)(t.a,{href:"/docs/zh-CN/concepts/protocol/transactions",children:"in the docs"}),"."]}),"\n",(0,n.jsx)(t.p,{children:"Authorization, on the other hand, must be performed on a smart contract itself, the simplest way is just to check whether caller is allowed to perform an action:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:'assert_eq!(\n            env::predecessor_account_id(),\n            self.tokens.owner_id,\n            "Unauthorized"\n        );\n'})}),"\n",(0,n.jsx)(t.h3,{id:"nft-usage",children:"NFT usage"}),"\n",(0,n.jsx)(t.p,{children:"After we\u2019ve learned how to authenticate users and how to authorize NFTs usage, let\u2019s find out how we can actually use them in our application."}),"\n",(0,n.jsx)(t.p,{children:"Since we essentially have two backends in our application - server and smart contract(s), they both can use NFTs for different purposes:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Server usually uses NFTs for actual functional purposes, e.g. by treating NFT as an in-game character, it can read its properties and stats and apply them using some logic."}),"\n",(0,n.jsx)(t.li,{children:"Smart contract is responsible for NFTs ownership, as well as NFTs creation, modification and burning (destruction)."}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"This is the point where the NFT data storage model comes into place. Let\u2019s recall, that there are 3 possible options:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsx)(t.li,{children:"Store data in a smart-contract (on-chain)."}),"\n",(0,n.jsxs)(t.li,{children:["Store data in an ",(0,n.jsx)(t.a,{href:"/docs/zh-CN/concepts/storage/storage-solutions",children:"off-chain decentralized storage"}),", like IPFS (off-chain)."]}),"\n",(0,n.jsx)(t.li,{children:"Store data in an application itself (in-application)."}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"First 2 approaches provide good decentralization, but make NFT harder to work with, especially if we need to modify its properties. Let\u2019s consider usage options depending on a storage model used:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:["On-chain storage:","\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Server can read data from the blockchain by making an API call. Server can\u2019t directly modify data, it should make a smart contract call instead (by issuing a transaction)."}),"\n",(0,n.jsx)(t.li,{children:"Smart contract can directly read/modify NFT data."}),"\n",(0,n.jsx)(t.li,{children:"Clients can read all data directly from the blockchain."}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["Off-chain storage:","\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Server can read data from storage by making an API call. Data on the off-chain storage is usually immutable, so no modifications are possible."}),"\n",(0,n.jsx)(t.li,{children:"Smart contract cannot read data directly, an Oracle should be used. Data cannot be modified from it."}),"\n",(0,n.jsx)(t.li,{children:"Clients should read data from both blockchain and off-chain storage."}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["In-application storage:","\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Server can read/modify data from its own database."}),"\n",(0,n.jsx)(t.li,{children:"Smart contract cannot read data directly, an Oracle should be used. Data cannot be modified from it."}),"\n",(0,n.jsx)(t.li,{children:"Clients should read data from both blockchain and server."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"Depending on a particular use case, any approach, or combination of them, can be used. The simplest case is when we don\u2019t have any dynamic NFT data, and we can easily divide data by domains:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Data that is used by smart contracts is stored on-chain."}),"\n",(0,n.jsx)(t.li,{children:"Other data is stored either off-chain or in-application."}),"\n"]}),"\n",(0,n.jsx)("div",{align:"center",children:(0,n.jsx)("img",{src:"/docs/assets/web3/nfts-13.png",alt:"image",width:"400"})}),"\n",(0,n.jsx)(t.p,{children:"In this approach the server needs to read data from the smart contract, and, optionally, from an off-chain storage (like IPFS or Database)."}),"\n",(0,n.jsx)(t.p,{children:"This will work well for simple use cases, but everything becomes more complicated if we need to have some dynamic data associated with NFTs. E.g we may want to have experience points associated with our game character. Such data can be stored either on-chain or in-application (off-chain storage is also possible, but it\u2019s more involved, so we won\u2019t discuss it here)."}),"\n",(0,n.jsx)(t.p,{children:"In case of in-application storage, data can be modified by a server without any problems, but there are few drawbacks:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"In order to read this data, clients should make an API call to the server. This adds a centralized point for our NFT, and may not be suitable for all applications."}),"\n",(0,n.jsxs)(t.li,{children:["If a smart contract requires this data, a server should serve as a ",(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Blockchain_oracle",children:"Blockchain Oracle"}),", which complicates things."]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"If we want our server to serve as an oracle for our smart contract, the easiest way is to cryptographically sign server\u2019s data and verify it on the contract\u2019s side (server\u2019s public key that was used for signing should be stored in a contract in this case)."}),"\n",(0,n.jsxs)(t.p,{children:["In order to prevent replay attacks, signed data should include a timestamp, which should also be verified. However, there\u2019s one trick to this - smart contracts can\u2019t access current time, since it would make them non-deterministic. Instead, transaction signature time can be used - it can be accessed using ",(0,n.jsx)(t.code,{children:"env::block_timestamp()"})," function."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"image",src:a(61619).Z+"",width:"1600",height:"933"})}),"\n",(0,n.jsx)(t.p,{children:"In order to avoid all these complications, we can instead store dynamic data on-chain, and use smart contract calls to update it."}),"\n",(0,n.jsx)("div",{align:"center",children:(0,n.jsx)("img",{src:"/docs/assets/web3/nfts-15.png",alt:"image",width:"500"})}),"\n",(0,n.jsx)(t.p,{children:"Such an approach has one drawback - in order to call a smart contract\u2019s method, a transaction should be created by the server, and in order to create a transaction it must be signed using an account\u2019s key. That\u2019s why a separate NEAR account should be created to be used by the server. Actions on the smart contract can be configured to authorize only this account, so regular users will be disallowed from modifying such data."}),"\n",(0,n.jsx)(t.p,{children:"Yet another option is to store data on the server-side, but a smart contract can authorize only a server account for calls that rely on this data. As with the previous scenario, the server must have its own NEAR account."}),"\n",(0,n.jsx)("div",{align:"center",children:(0,n.jsx)("img",{src:"/docs/assets/web3/nfts-16.png",alt:"image",width:"500"})}),"\n",(0,n.jsx)(t.p,{children:"In general, the approach of storing dynamic data on the Smart Contract side is much easier, but an important constraint should be considered - storing data on the blockchain is not cheap, so an appropriate method can be chosen depending on a scenario."}),"\n",(0,n.jsx)(t.p,{children:"By now, we\u2019ve covered methods to store and interact with NFTs from our application, an exact strategy should be chosen depending on use cases and constraints. A few things to remember:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Storing NFTs data in a centralized storage (like an application's database) goes against Web 3 philosophy, and should be used sparingly and with care."}),"\n",(0,n.jsx)(t.li,{children:"Storage on the blockchain is not cheap, so decentralized off-chain storages can be used to store large data."}),"\n",(0,n.jsx)(t.li,{children:"Storing and using dynamic NFT data is quite tricky, and should be carefully designed. If such dynamic data is needed by smart contracts, it\u2019s better to store it inside this contract if possible."}),"\n"]}),"\n",(0,n.jsx)(t.h3,{id:"nft-minting",children:"NFT minting"}),"\n",(0,n.jsx)(t.p,{children:"So far, we\u2019ve discussed only how to use NFTs in the application, but how do they get created?"}),"\n",(0,n.jsx)(t.p,{children:"In the blockchain world, creation of new NFTs is usually called minting. And as with traditional digital assets, there are few ways how to create them:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["Users can mint them directly. This can be done by either allowing creation of NFTs from scratch, or by using more complex processes, like breeding or upgrading. The most famous example of such process is breeding in ",(0,n.jsx)(t.a,{href:"https://www.cryptokitties.co/",children:"CryptoKitties"})," game - new NFTs are created by combining existing ones. With this approach users usually have to pay to cover the storage and gas cost of NFTs creation."]}),"\n",(0,n.jsxs)(t.li,{children:["NFTs can be distributed by the developer to a set of users - it is usually called ",(0,n.jsx)(t.a,{href:"https://www.investopedia.com/terms/a/airdrop-cryptocurrency.asp",children:"NFTs airdrop"}),". Most often this is used as a marketing strategy to kickstart NFTs usage in applications. Storage and gas costs in this case are covered by developers."]}),"\n",(0,n.jsx)(t.li,{children:"NFTs can be bought on a market or obtained from the lootbox. Depending on an exact strategy, costs can either be paid by a user or by developer. Also, in this case NFTs sometimes can be minted on-demand, to avoid paying upfront costs."}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["An exact strategy used for NFTs minting depends on application use cases. However, almost always there\u2019ll be an ",(0,n.jsx)(t.code,{children:"nft_mint _function"})," defined in a smart contract, which will handle creation of new tokens. This function itself isn't defined ",(0,n.jsx)(t.a,{href:"https://nomicon.io/Standards/NonFungibleToken/",children:"in the standard"})," and is up to the application to implement, but the standard library provides a core implementation for it - ",(0,n.jsx)(t.a,{href:"https://docs.rs/near-contract-standards/latest/near_contract_standards/non_fungible_token/core/struct.NonFungibleToken.html#method.internal_mint",children:"mint_internal"}),". On top of this function an additional logic, e.g. for authorization, can be added:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:'#[payable]\npub fn nft_mint(\n    &mut self,\n    token_id: TokenId,\n    receiver_id: AccountId,\n    token_metadata: TokenMetadata,\n) -> Token {\n    assert_eq!(\n        env::predecessor_account_id(),\n        self.tokens.owner_id,\n        "Unauthorized"\n    );\n\n    let token = self\n        .tokens\n        .internal_mint(token_id, receiver_id, Some(token_metadata));\n\n    return token;\n}\n'})}),"\n",(0,n.jsx)(t.p,{children:"This approach is quite simple, but everything becomes a bit complicated if we want to provide some on-demand minting functionality to avoid paying upfront costs. For example, we may want to create a lootbox with a set of predefined items appearing with some probability."}),"\n",(0,n.jsxs)(t.p,{children:["One approach is to handle this logic on a server side, in this case the server will call ",(0,n.jsx)(t.code,{children:"nft_mint"})," function with computed parameters. However, in this case developers will have to pay the cost of minting. If we want to avoid this, loot box logic can be moved into the smart contract itself. If users want to open a loot box, he can call a smart contract function and pay for this action (e.g. by using NEAR or Fungible Tokens). Developers would only need to pay for a lootbox configuration costs, like possible items and their probabilities."]}),"\n",(0,n.jsx)(t.h2,{id:"blockchain-onboarding",children:"Blockchain Onboarding"}),"\n",(0,n.jsx)(t.p,{children:"Before designing an onboarding strategy, the target audience should be carefully analyzed. As we briefly mentioned before, users can be divided into two broad buckets:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsx)(t.li,{children:"Users that are already familiar with blockchain, have their own wallets and understand cryptocurrency basics."}),"\n",(0,n.jsx)(t.li,{children:"\u201cCasual\u201d users that aren\u2019t familiar with blockchain and don\u2019t know much about it."}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"If only the first category is targeted, then everything is quite simple - users are already familiar with main concepts, and will have no problem connecting their own wallet or creating a new one. However, if we want to target the second category of users as well, a strategy has to be developed to make onboarding into the blockchain world as smooth as possible. While a lot relies on proper UX and is very application-specific, a few architectural patterns and technologies exist to simplify this process: custodial wallets, NEAR drops, Prepaid Gas and Implicit Accounts."}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.a,{href:"https://www.coindesk.com/learn/custodial-wallets-vs-non-custodial-crypto-wallets/",children:"Custodial Wallet"})," is a wallet which is managed by a third party. In our case, a wallet can be created and stored on a server side, and all blockchain operations could be done using the server as a proxy."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"image",src:a(8852).Z+"",width:"1600",height:"914"})}),"\n",(0,n.jsx)(t.p,{children:"In this way, users can remain unaware about the intricacies of blockchain until they are comfortable enough to claim ownership of this account. Once they are ready, the server can transfer the account's ownership and remove it from the server. However, despite simplifying UX for the users, such approach has a few significant drawbacks:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Users should trust our application to manage their accounts."}),"\n",(0,n.jsx)(t.li,{children:"Accounts creation is not free, so unless developers want to pay for it, funds should be transferred from a user to cover this cost. Traditional payment methods can be used, like PayPal or Apple/Google Pay. However, such an approach should be used with care for mobile applications due to app stores policies. Alternatively, NEAR Implicit Accounts can be used to avoid paying for account creation."}),"\n",(0,n.jsxs)(t.li,{children:["Unless we want to leave a custodial wallet as the only supported wallet type, we need to support both types of wallets (custodial and non-custodial) in our application. This will increase implementations complexity, since we need to support 2 transaction types:","\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Server-signed transactions in case of custodial wallet."}),"\n",(0,n.jsx)(t.li,{children:"Client-signed transactions in case of non-custodial wallet."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["As we mentioned above, ",(0,n.jsx)(t.a,{href:"/concepts/protocol/account-id#implicit-address",children:"Implicit Accounts"})," can be used to avoid paying account creation costs. This is especially useful for custodial wallets, since it allows us to create a NEAR Account free of charge. Basically, they work like an Ethereum/Bitcoin-style account by using a public key as an account id, and later can be converted to a full NEAR account. However, they have drawbacks as well. First of all, human-readable account names cannot be used. Also, if we want to convert it to a proper NEAR account, which can support Functional Call keys, the account creation fee still has to be paid."]}),"\n",(0,n.jsxs)(t.p,{children:["While being very powerful, custodial accounts are quite complex and tricky to implement. An alternative approach to ease users onboarding is to simplify creation of a wallet itself. In NEAR, we can do this using ",(0,n.jsx)(t.a,{href:"https://near.org/blog/send-near-to-anyone-with-near-drops/",children:"NEAR Drops"}),". It allows us to generate a link that guides users through a quick wallet creation process. However, the same problem as for the custodial accounts applies - creation of an account is not free. That\u2019s why, such a link has NEAR tokens attached to it to cover account creation cost and to serve as an initial balance for a newly created wallet. And as with custodial accounts, funds should be transferred from a user to cover this cost using traditional payment channels."]}),"\n",(0,n.jsxs)(t.p,{children:["Another option to simplify onboarding is usage of the ",(0,n.jsx)(t.code,{children:"Prepaid Gas"})," concept. For example, we can issue a Functional Call key that allows users to interact with blockchain without having an account created. In this case funds will be drawn from the developer's account. This can be used for demo purposes, or to allow users without a NEAR account to perform some smart contract actions."]}),"\n",(0,n.jsx)(t.h2,{id:"nft-marketplace",children:"NFT Marketplace"}),"\n",(0,n.jsx)(t.p,{children:"At this point, we\u2019ve covered in detail how to integrate NFTs into our Web 2 application, but we\u2019ve stayed away from the economy part. The essential part for having a functioning economy is a marketplace where users can freely trade and exchange their NFTs. Such a marketplace usually consists of a smart contract and a client application. This smart contract is closely integrated with a NFT\u2019s smart contract using the cross-contract calls. The reason for having a separate smart contract is two-fold:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"This provides a better separation of concerns - we can modify and upgrade our marketplace independently from the NFT contract."}),"\n",(0,n.jsx)(t.li,{children:"Multiple marketplaces can be used - e.g. we can have an internal marketplace, and in addition to it users can list their NFTs on external marketplaces. This is possible because a common NFT standard exists that all marketplaces can rely on."}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"General flow of a simple marketplace integration can look like this:"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"image",src:a(51435).Z+"",width:"1600",height:"958"})}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:["Client calls the ",(0,n.jsx)(t.a,{href:"https://nomicon.io/Standards/NonFungibleToken/ApprovalManagement#2-approval-with-cross-contract-call",children:"nft_approve"})," method on the NFT smart contract. This will approve Marketplace Smart Contract to sell this NFT."]}),"\n",(0,n.jsxs)(t.li,{children:["After approving an account, NFT smart contract issues a cross-contract call to the Marketplace to create a sale object. Arguments for this call are provided as part of the ",(0,n.jsx)(t.code,{children:"nft_approve"})," call."]}),"\n",(0,n.jsx)(t.li,{children:"Another user wants to buy the NFT on sale, so he issues a call to the marketplace contract offering to buy it. An exact call signature for such action is not standardized and depends on marketplace implementation."}),"\n",(0,n.jsxs)(t.li,{children:["If an offer to buy a NFT is valid, Marketplace issues an ",(0,n.jsx)(t.a,{href:"https://nomicon.io/Standards/NonFungibleToken/Payout",children:"nft_transfer_payout"})," call to transfer the NFT and return payout information. This information is used by the Marketplace to distribute profits from the sale between recipients. In the simplest case, all profits go to a seller."]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"Such flow looks relatively simple, but a few important details are missing."}),"\n",(0,n.jsx)(t.p,{children:"First of all, in order to create a sale, storage needs to be paid for. Usually, the seller is the one who needs to pay for it, but other models are possible - e.g. marketplace or application developers could cover the cost. If we want users to pay for a sale, an approach with storage reservation can be used:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Before approving NFT for sale, a user should reserve storage on the Marketplace contract to cover sale storage requirements."}),"\n",(0,n.jsx)(t.li,{children:"After the NFT is bought or delisted, the user can withdraw storage reservation (remember, that in NEAR storage staking model is used, so data can be deleted and locked tokens refunded)."}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["While this model is relatively straightforward, it\u2019s not ideal from the UX perspective - users must make a separate action to reserve storage if they want to sell their NFTs. To improve this, we can combine ",(0,n.jsx)(t.code,{children:"nft_approve"})," call with storage reservation, and automatically refund back the storage cost after the sale is removed."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"image",src:a(5473).Z+"",width:"1600",height:"1247"})}),"\n",(0,n.jsx)(t.p,{children:"Another missing thing is how a client can read data about available sales. Of course, sales information can be read directly from a smart contract, but available data structures are not optimized for searching or filtering. Also, we would have to join data from the NFT and Marketplace contracts on the client side, which isn\u2019t efficient. In order to solve these problems, an indexer can be used to aggregate data into a suitable database, where data can be stored in a way optimal for retrieval (e.g. a relational database or an ElasticSearch index can be used)."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"image",src:a(56826).Z+"",width:"1600",height:"913"})}),"\n",(0,n.jsx)(t.p,{children:"This is just one example of how a marketplace can be designed, but with it we\u2019ve covered all basic concepts and problems. Most important points to remember:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"It\u2019s better to implement a marketplace as a separate contract."}),"\n",(0,n.jsx)(t.li,{children:"Storage management should be carefully designed, with UX in mind."}),"\n",(0,n.jsx)(t.li,{children:"In order to implement a proper searching/filtering functionality, a separate indexing service is needed."}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["An example of a simple marketplace ",(0,n.jsx)(t.a,{href:"/docs/zh-CN/tutorials/nfts/marketplace",children:"can be found here"}),". A more sophisticated marketplace may allow purchases with Fungible Tokens as payment."]}),"\n",(0,n.jsx)(t.h2,{id:"implementing-components",children:"Implementing Components"}),"\n",(0,n.jsx)(t.p,{children:"Now, let\u2019s explore our choice of libraries, frameworks and third-party solutions that can be used to implement our architecture."}),"\n",(0,n.jsx)(t.h4,{id:"client--server",children:"Client & Server"}),"\n",(0,n.jsx)(t.p,{children:"First of all, how can we interact with blockchain from our clients?"}),"\n",(0,n.jsxs)(t.p,{children:["If we need read-level access only, we can simply use the ",(0,n.jsx)(t.a,{href:"https://docs.near.org/api/rpc/setup",children:"REST API"}),", so it can be integrated into any language and technology without any problems. But everything becomes more complicated if we need to post transactions from a client. Remember, that transaction should be signed with a private key which is stored in a wallet:"]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"In case of a Functional Call key, it can be obtained from the wallet and used directly by the client."}),"\n",(0,n.jsx)(t.li,{children:"In case of a Full Access key, the user should be redirected to the wallet to approve a transaction."}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["A ",(0,n.jsx)(t.a,{href:"/tools/near-api-js/quick-reference",children:"JavaScript API"})," exists to cover all of these scenarios. It has all of the necessary functionality to integrate Web/Node.JS applications with blockchain. This SDK is a perfect choice for the Web-based clients, but it\u2019s not suitable for desktop or mobile based clients. Other libraries can be used for them:"]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.a,{href:"https://github.com/good1101/NearClientApi/tree/master/NearClient",children:".NET Client"})," - suitable for Unity or Xamarin."]}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://github.com/near/near-api-swift",children:"Swift"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://github.com/near/near-api-py",children:"Python"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://github.com/near/near-api-unity",children:"Unity"})}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"Same SDKs and libraries can be used for servers. The only difference is that a server cannot interact with a Wallet, so it must have access to a Full Access key, which should be stored and accessed in a secure way."}),"\n",(0,n.jsx)(t.p,{children:"Also, another solution is available if a server uses a technology that doesn\u2019t have NEAR SDK available for - we can create a separate (micro)service using the Node.js, which would handle all blockchain interactions:"}),"\n",(0,n.jsx)("div",{align:"center",children:(0,n.jsx)("img",{src:"/docs/assets/web3/nfts-21.png",alt:"image",width:"450"})}),"\n",(0,n.jsxs)(t.p,{children:["An example of such a proxy server ",(0,n.jsx)(t.a,{href:"https://github.com/near-examples/near-api-rest-server",children:"can be found here"}),"."]}),"\n",(0,n.jsx)(t.h4,{id:"contracts",children:"Contracts"}),"\n",(0,n.jsx)(t.p,{children:"As we discovered in a previous section, for our application we need two smart contracts: for NFT and for Marketplace. There are two options on how to get them - use in-house implementation or some third-party/SAAS solution. Both options are viable and have different pros/cons."}),"\n",(0,n.jsx)(t.p,{children:"If we want to create our own contract, we are fully in control and can implement anything we want. An obvious drawback, of course, is that it will take time and money to build it. Third-party solutions, on the other hand, are limited in their functionality and often cannot be easily extended. Also, they usually have some upfront costs and/or usage fees."}),"\n",(0,n.jsxs)(t.p,{children:["For an in-house NFT contract implementation a few resources can be used as a starting point. First of all, a ",(0,n.jsx)(t.a,{href:"https://docs.rs/near-contract-standards/latest/near_contract_standards/index.html",children:"Rust library"})," is available which implements most of the standard. Another option is to build an entire contract from scratch, a good guide on how to do this is available by ",(0,n.jsx)(t.a,{href:"/docs/zh-CN/tutorials/nfts/introduction",children:"this link"}),"."]}),"\n",(0,n.jsx)(t.p,{children:"Implementing an own Marketplace contract is more involved since there is no standard implementation. A few examples:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"/docs/zh-CN/tutorials/nfts/marketplace",children:"Basic marketplace example"})}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.a,{href:"https://paras.id/",children:"Paras "}),"marketplace contract - ",(0,n.jsx)(t.a,{href:"https://github.com/ParasHQ/paras-marketplace-contract/tree/master/paras-marketplace-contract/src",children:"source"}),"."]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["As for third-party solutions, the most complete one is ",(0,n.jsx)(t.a,{href:"https://www.mintbase.io/",children:"Mintbase"}),", which provides a full suite of components for NFTs integration - including contracts, indexer, API and a web client:"]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"image",src:a(66037).Z+"",width:"1600",height:"1069"})}),"\n",(0,n.jsxs)(t.p,{children:["Another option is to roll-out an own NFT contract and integrate with one of the third-party marketplaces, e.g. with ",(0,n.jsx)(t.a,{href:"https://paras.id/",children:"Paras"})," (",(0,n.jsx)(t.a,{href:"https://docs.paras.id/nft-smart-contract-integration",children:"integration docs"}),")."]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"image",src:a(35907).Z+"",width:"1600",height:"1166"})}),"\n",(0,n.jsx)(t.p,{children:"The major advantage of an external marketplace is the fact that they usually run their own indexer and expose collected data via an API, so we don\u2019t have to implement these components. However, they usually have their fee for providing them, so a cost-benefit analysis should be conducted before using them."}),"\n",(0,n.jsx)(t.h4,{id:"off-chain-storages",children:"Off-chain storages"}),"\n",(0,n.jsx)(t.p,{children:"Previously, we\u2019ve discussed that storage on the blockchain is not cheap, so in most cases some decentralized storage solution should be used. A few options are available:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.a,{href:"https://ipfs.io/",children:"IPFS "}),"- one of the first decentralized storage solutions, which is widely used in the blockchain world. However, in order to make sure that data is preserved on the network, an IPFS node(s) should be maintained."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.a,{href:"https://www.arweave.org/",children:"Arweawe"})," - blockchain-based decentralized storage."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.a,{href:"https://filecoin.io/",children:"Filecoin"})," - another blockchain-based storage."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.a,{href:"https://nft.storage/",children:"nft.storage"})," - a free service built on top of the IPFS and Filecoin."]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["A more in-depth overview of such solutions is available ",(0,n.jsx)(t.a,{href:"/docs/zh-CN/concepts/storage/storage-solutions",children:"in the docs"}),". In general, there's no \u201csilver bullet\u201d, so different solutions should be evaluated and the most suitable chosen. The main concerns while choosing a solution are availability guarantees, and cost."]}),"\n",(0,n.jsx)(t.h4,{id:"indexer",children:"Indexer"}),"\n",(0,n.jsx)(t.p,{children:"As we already determined, an indexing service is needed in order to support marketplace functionality. It usually consists of 3 components:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Indexer - processes transactions from a NEAR network and puts extracted data into a database."}),"\n",(0,n.jsx)(t.li,{children:"Database - database of choice to store extracted data."}),"\n",(0,n.jsx)(t.li,{children:"Indexer API - an API layer on top of the database."}),"\n"]}),"\n",(0,n.jsx)("div",{align:"center",children:(0,n.jsx)("img",{src:"/docs/assets/web3/nfts-24.png",alt:"image",width:"150"})}),"\n",(0,n.jsxs)(t.p,{children:["While any technology of choice can be used to implement Database and API, an indexer itself is can be implemented using both ",(0,n.jsx)(t.a,{href:"https://github.com/near/near-lake-framework-rs",children:"Rust"})," and ",(0,n.jsx)(t.a,{href:"https://github.com/near/near-lake-framework-js",children:"JavaScript"}),". See ",(0,n.jsx)(t.a,{href:"https://github.com/near-examples/near-lake-nft-indexer",children:"this example"})," written in Rust."]}),"\n",(0,n.jsxs)(t.p,{children:["Usually, an indexer works by extracting data from ",(0,n.jsx)(t.a,{href:"https://nomicon.io/Standards/EventsFormat",children:"Events"}),", which are basically just structured log messages written during contract execution."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.a,{href:"https://thegraph.com/en/",children:"The Graph"})," is an alternative to building an indexer from scratch. This is an Indexer-as-a-Service solution, which simplifies their creation and deployment. Guide on how to create a NEAR indexer is available ",(0,n.jsx)(t.a,{href:"https://thegraph.com/docs/en/supported-networks/near/",children:"by this link"}),"."]}),"\n",(0,n.jsx)(t.h4,{id:"automated-testing",children:"Automated Testing"}),"\n",(0,n.jsx)(t.p,{children:"Automated testing of the code is one of the pillars of modern software development. But how do we test our dApp?"}),"\n",(0,n.jsxs)(t.p,{children:["Recall that a smart contract is a pure function, which can be easily tested using Unit Tests. Guide on how to write them is available ",(0,n.jsx)(t.a,{href:"/docs/zh-CN/build/smart-contracts/testing/unit-test",children:"here"}),", and some examples can be found here. Another important kind of tests that is supported by NEAR are E2E tests, they can be executed either deploying contract code to either the local network environment (more info ",(0,n.jsx)(t.a,{href:"/docs/zh-CN/build/smart-contracts/testing/introduction",children:"here"}),"), or directly to ",(0,n.jsx)(t.code,{children:"testnet"}),", more info ",(0,n.jsx)(t.a,{href:"/docs/zh-CN/build/smart-contracts/testing/integration-test",children:"here"}),")."]}),"\n",(0,n.jsx)(t.p,{children:"Having both types of tests is equally important to ensure continuous quality of smart contracts, especially since contract upgrades usually aren\u2019t easy to perform (remember, that in DAOs upgrade itself might be governed by a community vote)."}),"\n",(0,n.jsx)(t.h2,{id:"non-functional-concerns",children:"Non-Functional Concerns"}),"\n",(0,n.jsx)(t.p,{children:"Last, but not least, let\u2019s cover important non-functional concerns for our architecture."}),"\n",(0,n.jsx)(t.h3,{id:"security",children:"Security"}),"\n",(0,n.jsx)(t.p,{children:"The most important thing to remember during the entire development is security, and especially the security of smart contracts. Since their code is public and an upgrade procedure is not trivial, it should be carefully audited for security issues and logical exploits."}),"\n",(0,n.jsx)(t.p,{children:"Another important thing that should be kept secure is a user's private key. In most cases, only Functional Call keys should be directly accessed from a client, and Full Access keys should be kept in a wallet. However, in some cases a Full Access key might have to be used directly (e.g. in case of server transaction signing scenarios). In such a case, it must be kept in a secure location and treated as a most sensitive secret, since its compromise might lead to a full account takeover."}),"\n",(0,n.jsx)(t.p,{children:"In general, before deploying an application to the NEAR mainnet, it\u2019s a good idea to conduct a full security audit."}),"\n",(0,n.jsx)(t.h3,{id:"scalability-and-availability",children:"Scalability and Availability"}),"\n",(0,n.jsx)(t.p,{children:"Another concern is scalability and availability of a solution. There are a lot of ways to scale traditional servers, but how do we scale our blockchain and make sure it\u2019s always available?"}),"\n",(0,n.jsxs)(t.p,{children:["Since blockchain is decentralized, it provides us with high-availability by design, and NEAR provides a great scalability by employing Proof-of-Stake consensus and sharding. However, in order to interact with a network, we need an RPC Node. NEAR maintains publicly available nodes for its networks (listed ",(0,n.jsx)(t.a,{href:"https://rpc.mainnet.near.org/status",children:"here"}),"), but it doesn't provide any performance or availability guarantees for them. So, in order to make sure our architecture is scalable and fault tolerant, we need to maintain our own cluster of RPC nodes, typically behind a load balancer."]}),"\n",(0,n.jsx)("div",{align:"center",children:(0,n.jsx)("img",{src:"/docs/assets/web3/nfts-25.png",alt:"image",width:"150"})}),"\n",(0,n.jsxs)(t.p,{children:["Information on how to set up an RPC node is available ",(0,n.jsx)(t.a,{href:"https://near-nodes.io/rpc",children:"here"}),"."]}),"\n",(0,n.jsx)(t.p,{children:"Also, to guarantee availability and scalability of a whole system, all used third-party services should be reviewed as well. For example, if IPFS is used as a storage for NFTs, pinning nodes and IPFS gateway should be scalable and fault tolerant."}),"\n",(0,n.jsx)(t.h3,{id:"costs",children:"Costs"}),"\n",(0,n.jsx)(t.p,{children:"When building a Web 3 application, it\u2019s important to remember that cost calculation is somewhat different from Web 2 applications. Additional costs can be broken down into several categories:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsx)(t.li,{children:"Smart Contracts deployment costs. While deploying on NEAR testnet or local environment, it\u2019s essentially free of charge. However, when deploying into the mainnet, developers will be charged for storage and gas cost. Gas cost for a contract deployment transaction is relatively small (around 0.04$ at the time of writing). On the other hand, storage costs can be quite substantial, e.g. a 150KB contract (compiled) will cost around 20$."}),"\n",(0,n.jsx)(t.li,{children:"Smart Contracts usage cost. In Web 3, users pay for smart contract calls, so in order to make sure users aren\u2019t discouraged to interact with a contract due to a high cost, it should be optimized to incur the lowest cost possible. This is especially important for storage costs, since gas is relatively cheap."}),"\n",(0,n.jsxs)(t.li,{children:["If we want to use a privately hosted RPC node for better availability, its operational costs should be taken into account as well. Cost breakdown can be found ",(0,n.jsx)(t.a,{href:"https://near-nodes.io/rpc/hardware-rpc",children:"here"}),", a rough estimation is about 290$ per node per month (and remember that we need at least 2 nodes for redundancy)."]}),"\n",(0,n.jsxs)(t.li,{children:["Cost of a privately hosted indexer (if it\u2019s used). More information can be found ",(0,n.jsx)(t.a,{href:"/concepts/advanced/near-indexer-framework",children:"here"}),", a rough estimation for the costs is about 100$ per month."]}),"\n",(0,n.jsx)(t.li,{children:"Third party services costs."}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},97793:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/nfts-10-cf5a1e0a8484248b1d9e58b89618beb6.png"},24660:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/nfts-11-d2d0e3797576fa9d80a1e3fba44e331e.png"},27273:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/nfts-12-73f6d9b7b88b0623bd211b3a8ab20e17.png"},61619:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/nfts-14-e62b9fc54d296752d698227dc98c62ec.png"},8852:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/nfts-17-f17f4e76477a1ea3649f714227975f92.png"},51435:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/nfts-18-54bd03fd1d3567a1c7877f269b3bdecb.png"},5473:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/nfts-19-9ac3b15837103a88e9fe2ceb81dce40a.png"},56826:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/nfts-20-90353ae28a28e2d89e40ae27692f3dc3.png"},66037:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/nfts-22-49aa7207c199896b74dd0e1b9facffbe.png"},35907:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/nfts-23-b67fefc5c23d906826bc8e699ef2045c.png"},5645:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/nfts-4-17693c3fa516e755ed0faf1b9606f66d.png"},52538:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/nfts-5-4224a8cb985282aa99d8e6b07ae24891.png"},47471:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/nfts-6-e034e35ef285380ad33bace8b738b9c1.png"},44705:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/nfts-7-2e85cec11261f8ec4b6b6c010609116b.png"},61243:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/nfts-8-67d9a6875a8292a33fed61679c09d38b.png"},11151:(e,t,a)=>{a.d(t,{Z:()=>r,a:()=>o});var n=a(67294);const i={},s=n.createContext(i);function o(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);