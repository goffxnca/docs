"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[409],{81260:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>r,default:()=>u,frontMatter:()=>c,metadata:()=>i,toc:()=>l});var a=n(85893),s=n(11151);const c={id:"reentrancy",title:"Reentrancy Attacks"},r=void 0,i={id:"build/smart-contracts/security/reentrancy",title:"Reentrancy Attacks",description:"Between a cross-contract call and its callback any method of your contract can be executed. Not taking this into account is one of the main sources of exploits. It is so common that it has its own name: reentrancy attacks.",source:"@site/../docs/2.build/2.smart-contracts/security/reentrancy.md",sourceDirName:"2.build/2.smart-contracts/security",slug:"/build/smart-contracts/security/reentrancy",permalink:"/docs/zh-CN/build/smart-contracts/security/reentrancy",draft:!1,unlisted:!1,editUrl:"https://github.com/near/docs/edit/master/website/../docs/2.build/2.smart-contracts/security/reentrancy.md",tags:[],version:"current",lastUpdatedBy:"gagdiez",lastUpdatedAt:1712759479e3,frontMatter:{id:"reentrancy",title:"Reentrancy Attacks"},sidebar:"build",previous:{title:"Front Running",permalink:"/docs/zh-CN/build/smart-contracts/security/frontrunning"},next:{title:"Random Numbers",permalink:"/docs/zh-CN/build/smart-contracts/security/random"}},o={},l=[{value:"Example",id:"example",level:3}];function d(e){const t={code:"code",em:"em",h3:"h3",hr:"hr",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(t.p,{children:["Between a cross-contract call and its callback ",(0,a.jsx)(t.strong,{children:"any method of your contract can be executed"}),". Not taking this into account is one of the main sources of exploits. It is so common that it has its own name: ",(0,a.jsx)(t.strong,{children:"reentrancy attacks"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"Always make sure to keep your state in a consistent state after a method finishes executing. Assume that:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Any method could be executed between a method execution and its callback."}),"\n",(0,a.jsx)(t.li,{children:"The same method could be executed again before the callback kicks in."}),"\n"]}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h3,{id:"example",children:"Example"}),"\n",(0,a.jsxs)(t.p,{children:["Imagine that we develop a ",(0,a.jsx)(t.code,{children:"deposit_and_stake"})," with the following ",(0,a.jsx)(t.strong,{children:"wrong logic"}),": (1) The user sends us money, (2) we add it to its balance, (3) we try to stake it in a validator, (4) if the staking fails, we remove the balance in the callback. Then, a user could schedule a call to withdraw between (2) and (4), and, if the staking failed, we would send money twice to the user."]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.img,{src:"https://miro.medium.com/max/1400/1*VweWHQYGLBa70uceiWHLQA.png",alt:"img"}),"\n",(0,a.jsx)(t.em,{children:"Between a cross-contract call and the callback anything could happen"})]}),"\n",(0,a.jsx)(t.p,{children:"Luckily for us the solution is rather simple. Instead of immediately adding the money to our user\u2019s balance, we wait until the callback. There we check, and if the staking went well, then we add it to their balance."}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.img,{src:"https://miro.medium.com/max/1400/1*o0YVDCp_7l-L3njJMGhU4w.png",alt:"img"}),"\n",(0,a.jsx)(t.em,{children:"Correct way to handle deposits in a cross-contract call"})]})]})}function u(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},11151:(e,t,n)=>{n.d(t,{Z:()=>i,a:()=>r});var a=n(67294);const s={},c=a.createContext(s);function r(e){const t=a.useContext(c);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(c.Provider,{value:t},e.children)}}}]);