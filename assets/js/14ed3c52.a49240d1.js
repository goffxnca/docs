"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[7216],{36924:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var o=t(85893),r=t(11151);const i={},a=void 0,s={id:"build/primitives/dao/smart-contract/create-proposal",title:"create-proposal",description:"",source:"@site/../_docs/2.build/5.primitives/dao/smart-contract/create-proposal.md",sourceDirName:"2.build/5.primitives/dao/smart-contract",slug:"/build/primitives/dao/smart-contract/create-proposal",permalink:"/docs/build/primitives/dao/smart-contract/create-proposal",draft:!1,unlisted:!1,editUrl:"https://github.com/near/docs/edit/master/website/../_docs/2.build/5.primitives/dao/smart-contract/create-proposal.md",tags:[],version:"current",frontMatter:{}},c={},l=[];function u(n){const e={code:"code",pre:"pre",...(0,r.a)(),...n.components};return(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-rust",children:'// Account ID that represents a token in near-sdk v3\n// Need to keep it around for backward compatibility\npub type OldAccountId = String;\n\n// How the voting policy votes get weighted.\n#[near(serializers = [json, borsh])\n#[derive(Clone, PartialEq)]\n#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]\npub enum WeightKind {\n  // Using token amounts and total delegated at the moment.\n  TokenWeight,\n  // Weight of the group role. Roles that don\'t have scoped group are not supported.\n  RoleWeight,\n}\n\n// Direct weight or ratio to total weight, used for the voting policy\n#[near(serializers = [json, borsh])\n#[derive(Clone)]\n#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]\n#[serde(untagged)]\npub enum WeightOrRatio {\n  Weight(U128),\n  Ratio(u64, u64),\n}\n\n// Defines configuration of the vote\n#[near(serializers = [json, borsh])\n#[derive(Clone)]\n#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]\npub struct VotePolicy {\n  // Kind of weight to use for votes.\n  pub weight_kind: WeightKind,\n  // Minimum number required for vote to finalize.\n  // If weight kind is TokenWeight - this is minimum number of tokens required.\n  //     This allows to avoid situation where the number of staked tokens from total supply is too small.\n  // If RoleWeight - this is minimum number of votes.\n  //     This allows to avoid situation where the role is got too small but policy kept at 1/2, for example.\n  pub quorum: U128,\n  // How many votes to pass this vote.\n  pub threshold: WeightOrRatio,\n}\n\n#[near(serializers = [json, borsh])]\n#[derive(Clone)]\n#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]\npub enum RoleKind {\n  // Matches everyone, who is not matched by other roles.\n  Everyone,\n  // Member greater or equal than given balance. Can use `1` as non-zero balance.\n  Member(U128),\n  // Set of accounts.\n  Group(HashSet<AccountId>),\n}\n\n#[near(serializers = [json, borsh])]\n#[derive(Clone)]\n#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]\npub struct RolePermission {\n  // Name of the role to display to the user.\n  pub name: String,\n  // Kind of the role: defines which users this permissions apply.\n  pub kind: RoleKind,\n  // Set of actions on which proposals that this role is allowed to execute.\n  // <proposal_kind>:<action>\n  pub permissions: HashSet<String>,\n  // For each proposal kind, defines voting policy.\n  pub vote_policy: HashMap<String, VotePolicy>,\n}\n\n// Defines voting / decision making policy of this DAO\n#[near(serializers = [json, borsh])]\n#[derive(Clone)]\n#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]\npub struct Policy {\n  // List of roles and permissions for them in the current policy.\n  pub roles: Vec<RolePermission>,\n  // Default vote policy. Used when given proposal kind doesn\'t have special policy.\n  pub default_vote_policy: VotePolicy,\n  // Proposal bond.\n  pub proposal_bond: U128,\n  // Expiration period for proposals.\n  pub proposal_period: U64,\n  // Bond for claiming a bounty.\n  pub bounty_bond: U128,\n  // Period in which giving up on bounty is not punished.\n  pub bounty_forgiveness_period: U64,\n}\n\n// Versioned policy\n#[near(serializers = [json, borsh])]\n#[derive(Clone)]\n#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]\npub enum VersionedPolicy {\n  // Default policy with given accounts as council.\n  Default(Vec<AccountId>),\n  Current(Policy),\n}\n\n// Function call arguments\n#[near(serializers = [json, borsh])]\n#[cfg_attr(not(target_arch = "wasm32"), derive(Clone, Debug))]\npub struct ActionCall {\n  method_name: String,\n  args: Base64VecU8,\n  deposit: U128,\n  gas: U64,\n}\n\n// Bounty information.\n#[near(serializers = [json, borsh])]\n#[derive(Clone)]\n#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]\npub struct Bounty {\n  /// Description of the bounty.\n  pub description: String,\n  /// Token the bounty will be paid out.\n  /// Can be "" for $NEAR or a valid account id.\n  pub token: OldAccountId,\n  /// Amount to be paid out.\n  pub amount: U128,\n  /// How many times this bounty can be done.\n  pub times: u32,\n  /// Max deadline from claim that can be spend on this bounty.\n  pub max_deadline: U64,\n}\n\n// Info about factory that deployed this contract and if auto-update is allowed\n#[near(serializers = [json, borsh])]\n#[cfg_attr(not(target_arch = "wasm32"), derive(Clone, Debug))]\npub struct FactoryInfo {\n  pub factory_id: AccountId,\n  pub auto_update: bool,\n}\n\n// Function call arguments\n#[near(serializers = [json, borsh])]\n#[cfg_attr(not(target_arch = "wasm32"), derive(Clone, Debug))]\npub struct PolicyParameters {\n  pub proposal_bond: Option<U128>,\n  pub proposal_period: Option<U64>,\n  pub bounty_bond: Option<U128>,\n  pub bounty_forgiveness_period: Option<U64>,\n}\n\n// Votes recorded in the proposal\n#[near(serializers = [json, borsh])]\n#[derive(Clone, Debug)]\npub enum Vote {\n  Approve = 0x0,\n  Reject = 0x1,\n  Remove = 0x2,\n}\n\n// Configuration of the DAO\n#[near(serializers = [json, borsh])]\n#[derive(Clone, Debug)]\npub struct Config {\n  // Name of the DAO.\n  pub name: String,\n  // Purpose of this DAO.\n  pub purpose: String,\n  // Generic metadata. Can be used by specific UI to store additional data.\n  // This is not used by anything in the contract.\n  pub metadata: Base64VecU8,\n}\n\n// Kinds of proposals, doing different action\n#[near(serializers = [json, borsh])]\n#[cfg_attr(not(target_arch = "wasm32"), derive(Clone, Debug))]\npub enum ProposalKind {\n  // Change the DAO config.\n  ChangeConfig { config: Config },\n  // Change the full policy.\n  ChangePolicy { policy: VersionedPolicy },\n  // Add member to given role in the policy. This is short cut to updating the whole policy.\n  AddMemberToRole { member_id: AccountId, role: String },\n  // Remove member to given role in the policy. This is short cut to updating the whole policy.\n  RemoveMemberFromRole { member_id: AccountId, role: String },\n  // Calls `receiver_id` with list of method names in a single promise.\n  // Allows this contract to execute any arbitrary set of actions in other contracts.\n  FunctionCall {\n      receiver_id: AccountId,\n      actions: Vec<ActionCall>,\n  },\n  // Upgrade this contract with given hash from blob store.\n  UpgradeSelf { hash: Base58CryptoHash },\n  // Upgrade another contract, by calling method with the code from given hash from blob store.\n  UpgradeRemote {\n      receiver_id: AccountId,\n      method_name: String,\n      hash: Base58CryptoHash,\n  },\n  // Transfers given amount of `token_id` from this DAO to `receiver_id`.\n  // If `msg` is not None, calls `ft_transfer_call` with given `msg`. Fails if this base token.\n  // For `ft_transfer` and `ft_transfer_call` `memo` is the `description` of the proposal.\n  Transfer {\n      // Can be "" for $NEAR or a valid account id.\n      token_id: OldAccountId,\n      receiver_id: AccountId,\n      amount: U128,\n      msg: Option<String>,\n  },\n  // Sets staking contract. Can only be proposed if staking contract is not set yet.\n  SetStakingContract { staking_id: AccountId },\n  // Add new bounty.\n  AddBounty { bounty: Bounty },\n  // Indicates that given bounty is done by given user.\n  BountyDone {\n      bounty_id: u64,\n      receiver_id: AccountId,\n  },\n  // Just a signaling vote, with no execution.\n  Vote,\n  // Change information about factory and auto update.\n  FactoryInfoUpdate { factory_info: FactoryInfo },\n  // Add new role to the policy. If the role already exists, update it. This is short cut to updating the whole policy.\n  ChangePolicyAddOrUpdateRole { role: RolePermission },\n  // Remove role from the policy. This is short cut to updating the whole policy.\n  ChangePolicyRemoveRole { role: String },\n  // Update the default vote policy from the policy. This is short cut to updating the whole policy.\n  ChangePolicyUpdateDefaultVotePolicy { vote_policy: VotePolicy },\n  // Update the parameters from the policy. This is short cut to updating the whole policy.\n  ChangePolicyUpdateParameters { parameters: PolicyParameters },\n}\n\n#[near(serializers = [json])]\npub struct ProposalInput {\n  /// Description of this proposal.\n  pub description: String,\n  /// Kind of proposal with relevant information.\n  pub kind: ProposalKind,\n}\n\n// Validator interface, for cross-contract calls\n#[ext_contract(ext_dao_contract)]\ntrait ExternalDaoContract {\n  fn add_proposal(&mut self, proposal: ProposalInput) -> Promise;\n}\n\n// Implement the contract structure\n#[near]\nimpl Contract {\n  #[payable]\n  pub fn create_proposal(&mut self, proposal: ProposalInput) -> Promise {\n    let promise = ext_dao_contract::ext(self.dao_contract.clone())\n      .with_attached_deposit(env::attached_deposit())\n      .with_static_gas(Gas(5*TGAS))\n      .add_proposal(proposal);\n\n    return promise.then( // Create a promise to callback query_greeting_callback\n      Self::ext(env::current_account_id())\n      .with_static_gas(Gas(50*TGAS))\n      .external_proposal_callback()\n    )\n  }\n\n  #[private] // Public - but only callable by env::current_account_id()\n  pub fn external_proposal_callback(&self, #[callback_result] call_result: Result<u64, PromiseError>) -> Option<u64> {\n    if call_result.is_err() {\n      log!("There was an error contacting external contract");\n      return None;\n    }\n\n    // Return the proposal id\n    let id = call_result.unwrap();\n    return Some(id);\n  }\n}\n'})})}function p(n={}){const{wrapper:e}={...(0,r.a)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(u,{...n})}):u(n)}},11151:(n,e,t)=>{t.d(e,{Z:()=>s,a:()=>a});var o=t(67294);const r={},i=o.createContext(r);function a(n){const e=o.useContext(i);return o.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:a(n.components),o.createElement(i.Provider,{value:e},n.children)}}}]);